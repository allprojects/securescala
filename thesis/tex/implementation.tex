\chapter{Implementation}
\label{cha:implementation}

\section{Free Monads}
\label{sec:free-monads}

\begin{itemize}
\item Given any Functor f, it gives rise to a Free Monad on it.
\item Nice way to get an embedded DSL that can be interpreted
\item Programs in DSL are first-class
\item Specify Interpreter independently from DSL
\item To look into them we \textbf{have} to execute them!
\end{itemize}

\section{Free Applicative Functors}
\label{sec:free-appl-funct}

\begin{itemize}
\item Applicative is weaker than Monad
\item (Even better: Applicatives compose!)
\item $\forall f. Monad f \rightarrow Applicative f$
  ``Every Monad has an Applicative instance''
\item $\not \forall f. Applicative f \rightarrow Monad f$
  ``Not every Applicative is also a Monad''
  \begin{itemize}
  \item ZipList
  \item Validation
  \item Concurrently/Futures(!)
% https://github.com/simonmar/async/pull/26
  \item Our DSL
  \end{itemize}
\item weaker = better for us
  \begin{itemize}
  \item optimizations
  \item static analysis
  \item inspect programs
  \item transform programs
  \end{itemize}
\end{itemize}

\section{Why mix}
\label{sec:why-mix}

\begin{itemize}
\item monads are inherently sequential
\item \texttt{ma >>= f} \textbf{requires} sequential evaluation of \texttt{ma}
  before \texttt{f} can be applied
\item unless cheating like scala.concurrent.Future
\item applicatives are not, can choose order of evaluation of effects
\end{itemize}

\subsection{Why hard divide between Applicative/Monad and not hybrid?}
\label{sec:why-hard-divide}

\begin{itemize}
\item mixing applicative that evaluates in parallel with monad is bad
\item really bad
\item don't do it
\item The law says that if f is both Applicative and Monad, it should
  hold that \texttt{(<*>) == ap}
  \begin{itemize}
  \item ap mf mx = do f <- mf; x <- mx; return (f x)
  \item no parallel evaluation allowed
  \item No Monad for Concurrently (async), no Monad for u
  \item details: you can otherwise get different results
  \end{itemize}
\end{itemize}

\subsubsection{CryptoF}
\label{sec:cryptof}

\begin{listing}[htp]
  \caption{OptiReactive example code}
  \scalafile{CryptoF.example}
  \label{lst:optireactive-example-code}
\end{listing}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End:
