\chapter{Implementation}
\label{cha:implementation}

\section{Free Monads}
\label{sec:free-monads}

\begin{itemize}
\item Given any Functor f, it gives rise to a Free Monad on it.
\item Nice way to get an embedded DSL that can be interpreted
\item Programs in DSL are first-class
\item Specify Interpreter independently from DSL
\item To look into them we \textbf{have} to execute them!
\end{itemize}

\section{Free Applicative Functors}
\label{sec:free-appl-funct}

\begin{itemize}
\item Applicative is weaker than Monad
\item (Even better: Applicatives compose!)
% \item $\forall f. Monad f \rightarrow Applicative f$
%   ``Every Monad has an Applicative instance''
% \item $\not \forall f. Applicative f \rightarrow$
%   ``Not every Applicative is also a Monad''
  \begin{itemize}
  \item ZipList
  \item Validation
  \item Our DSL
  \end{itemize}
\item weaker = better for us
  \begin{itemize}
  \item optimizations
  \item static analysis
  \item inspect programs
  \item transform programs
  \end{itemize}
\end{itemize}

\section{Why mix}
\label{sec:why-mix}

\begin{itemize}
\item monads are inherently sequential
\item \texttt{ma >>= f} \textbf{requires} sequential evaluation of \texttt{ma}
  before \texttt{f} can be applied
\item applicatives are not, can choose order of evaluation of effects
\end{itemize}

\subsection{Why hard divide between Applicative/Monad and not hybrid?}
\label{sec:why-hard-divide}

\begin{itemize}
\item mixing applicative that evaluates in parallel with monad is bad
\item really bad
\item don't do it
\item The law says that if f is both Applicative and Monad, it should
  hold that \texttt{(<*>) == ap}
  \begin{itemize}
  \item ap mf mx = do f <- mf; x <- mx; return (f x)
  \item no parallel evaluation allowed
  \item No Monad for Concurrently (async), no Monad for u
  \item details: you can otherwise get different results
  \end{itemize}
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End:
