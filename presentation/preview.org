# -*- org-confirm-babel-evaluate: nil -*-
#+Title: Secure computations for free
#+Author: Markus Hauck
#+Email: markus1189@gmail.com

#+OPTIONS: reveal_center:nil reveal_progress:t reveal_history:nil reveal_control:nil
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:t reveal_keyboard:t reveal_overview:t num:t
#+OPTIONS: reveal_width:1200 reveal_height:800
#+OPTIONS: toc:nil

#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 1.0
#+REVEAL_MAX_SCALE: 1.0
#+REVEAL_TRANS: none
#+REVEAL_THEME: blood
#+REVEAL_HLEVEL: 2
#+REVEAL_PLUGINS: (highlight markdown notes)
* Homomorphic encryption
- Allow computation on encrypted data
- fully homomorphic encryption (FHE)
  - computationally very expensive
- partial homomorphic encryption (PHE)
  - addition (Paillier)
  - multiplication (ElGamal)
  - equality (AES)
  - ordering (OPE)
* The general idea
- addition of encrypted numbers
  #+BEGIN_SRC scala
  (+) : Enc => Enc => Enc
  Enc(21) + Enc(21) = Enc(42)
  #+END_SRC
- if the current scheme is wrong, we need to do a *conversion*
- locally with *private* key: no problem
- remote on untrusted third party: *communication*
- conversion over network = *Effect*
  #+BEGIN_SRC scala
  (+) : Enc => Enc => ???[Enc]
  Enc(21) + Enc(21) = ???(Enc(42))
  #+END_SRC
- handle effects in functional programming = *Monads*
- create DSL based on monads = *Free Monads*
- (Free Applicatives for static analysis)
* Examples
** Example - Fibonacci
Plain Scala:
#+BEGIN_SRC scala
def fib(n: Int): Int =
  if (n <= 1) {
    1
  } else {
    fib(n-1) + fib(n-2)
  }
#+END_SRC
Using the DSL:
#+BEGIN_SRC scala
def fibHelper(one: Enc, two: Enc)(n: Enc): CryptoM[Enc] = for {
  cmp <- n <= one
  r <- if (cmp) {
    one.lifted
  } else for {
    (n1,n2) <- (n-one) tuple (n-two)
    (f1,f2) <- fibHelper(one,two)(n1) tuple fibHelper(one,two)(n2)
    s <- f1 + f2
  } yield s
} yield r

def fib(n: Enc): CryptoM[Enc] = for {
  (one,two) <- encrypt(Additive)(1) tuple encrypt(Additive)(2)
  r <- fibHelper(one,two)(n)
} yield r
#+END_SRC
** Example - Factorial
Plain Scala:
#+BEGIN_SRC scala
def factorial(n: Int): Int =
  if (n == 0) {
    1
  } else {
    n * factorial(n-1)
  }
#+END_SRC

Using the DSL:
#+BEGIN_SRC scala
def factorialHelper(zero: Enc, one: Enc)(n: Enc): CryptoM[Enc] = for {
  cond <- n =:= zero
  r <- if (cond) {
    one.lifted
  } else for {
    n1 <- n - one
    fact <- factorialHelper(zero,one)(n1)
    s <- n * fact
  } yield s
} yield r

def factorial(n: Enc): CryptoM[Enc] = for {
  (zero,one) <- encrypt(Multiplicative)(0) tuple (encrypt(Multiplicative)(1))
  r <- factorialHelper(zero, one)(n)
} yield r
#+END_SRC

** Example - Events
#+BEGIN_SRC scala
  val evenNumbers: String = """
SELECT *
FROM CryptoEvent as cevt
WHERE TheInterpreter.isEven(cevt.encValue)
"""

  val smaller100: String = """
SELECT *
FROM CryptoEvent as cevt
WHERE TheInterpreter.smaller100(cevt.encValue)
"""

object TheInterpreter {
  val keyRing = KeyRing.create
  val interp = LocalInterpreter(keyRing)

  def isEven(e: Enc): Boolean = interp(dsl.isEven(e))

  val onehundred = Common.encrypt(Comparable, keyRing)(100)
  def smaller100(e: Enc): Boolean =interp(e < onehundred)
}
#+END_SRC
* The End
- Lightweight DSL to express secure computations
- Interpreters can be defined for many purposes: local, remote, analysis
- Uses Free Monads and Free Applicative Functors
- Can exploit implicit parallelism automatically
- Requires translation into monadic style
* Details
** Implementations
*** Enc
#+BEGIN_SRC scala
sealed trait Enc
case class PaillierEnc(...) extends Enc { def +(that: PaillierEnc): PaillierEnc }
case class ElGamalEnc(...)  extends Enc { def *(that: ElGamalEnc): ElGamalEnc }
case class AesEnc(...)      extends Enc { def =:=(that: AesEnc): Boolean }
case class OpeEnc(...)      extends Enc; implicit val opeOrder = new Order[OpeEnc] {...}
#+END_SRC
*** Complete Functor definition
#+BEGIN_SRC scala
sealed trait CryptoF[+K]
case class Mult[K](lhs: Enc, rhs: Enc, k: ElGamalEnc => K) extends CryptoF[K]
case class Plus[K](lhs: Enc, rhs: Enc, k: PaillierEnc => K) extends CryptoF[K]
case class Equals[K](lhs: Enc, rhs: Enc, k: Boolean => K)  extends CryptoF[K]
case class Compare[K](lhs: Enc, rhs: Enc, k: Ordering => K) extends CryptoF[K]

case class Encrypt[K](s:Scheme, v: Int, k: Enc => K) extends CryptoF[K]
case class ToPaillier[K](v: Enc, k: PaillierEnc => K) extends CryptoF[K]
case class ToGamal[K](v: Enc, k: ElGamalEnc => K) extends CryptoF[K]
case class ToAes[K](v: Enc, k: AesEnc => K) extends CryptoF[K]
case class ToOpe[K](v: Enc, k: OpeEnc => K) extends CryptoF[K]

case class Sub[K](lhs: Enc, rhs: Enc, k: Enc => K) extends CryptoF[K]
case class Div[K](lhs: Enc, rhs: Enc, k: Enc => K) extends CryptoF[K]
case class IsEven[K](v: Enc, k: Boolean => K) extends CryptoF[K]
case class IsOdd[K](v: Enc, k: Boolean => K) extends CryptoF[K]
case class Embed[A,K](v: Crypto[A], k: CryptoM[A] => CryptoM[K]) extends CryptoF[K]
#+END_SRC

*** Complete base DSL
#+BEGIN_SRC scala
type Crypto[A] = FreeAp[CryptoF, A]
type CryptoM[A] = Free[CryptoF, A]

def multiply(lhs: Enc, rhs: Enc): Crypto[Enc]
def add(lhs: Enc, rhs: Enc): Crypto[Enc]
def equal(lhs: Enc, rhs: Enc): Crypto[Boolean]
def compare(lhs: Enc, rhs: Enc): Crypto[Ordering]

def encrypt(s: Scheme)(v: Int): Crypto[Enc]
def toPaillier(v: Enc): Crypto[PaillierEnc]
def toGamal(v: Enc): Crypto[ElGamalEnc]
def toAes(v: Enc): Crypto[AesEnc]
def toOpe(v: Enc): Crypto[OpeEnc]

def subtract(lhs: Enc, rhs: Enc): Crypto[Enc]
def divide(lhs: Enc, rhs: Enc): Crypto[Enc]

def isEven(v: Enc): Crypto[Boolean]
def isOdd(v: Enc): Crypto[Boolean]

def embed[A](v: Crypto[A]): CryptoM[A]
#+END_SRC

*** Infix operations
#+BEGIN_SRC scala
implicit class EncInfixOps(self: Enc) {
  def *(that: Enc)
  def +(that: Enc)
  def -(that: Enc)
  def /(that: Enc)
  def =:=(that: Enc)
  def ?|?(that: Enc)
  def <(that: Enc)
  def <=(that: Enc)
  def >(that: Enc)
  def >=(that: Enc)
}
#+END_SRC
*** Derived operations
#+BEGIN_SRC scala
def sumM[F[_]:Foldable](zero: PaillierEnc)(xs: F[Enc]): CryptoM[Enc] =
  xs.foldLeftM[CryptoM,Enc](zero)(add(_,_))

def sumA[F[_]:Traverse](zero: PaillierEnc)(xs: F[Enc]): Crypto[PaillierEnc] =
  sumOpt(xs).map(_.getOrElse(zero))

def sumOpt[F[_]:Traverse](xs: F[Enc]): Crypto[Option[PaillierEnc]] =
  xs.traverse(toPaillier).map(_.foldLeft(None: Option[PaillierEnc])(_ ⊹ Some(_)))

def productM[F[_]:Foldable](one: ElGamalEnc)(xs: F[Enc]): CryptoM[Enc] =
  xs.foldLeftM[CryptoM,Enc](one)(multiply(_,_))

def productA[F[_]:Traverse](one: ElGamalEnc)(xs: F[Enc]): Crypto[ElGamalEnc] =
  productOpt(xs).map(_.getOrElse(one))

def productOpt[F[_]:Traverse](xs: F[Enc]): Crypto[Option[ElGamalEnc]] =
  xs.traverse(toGamal).map(_.foldLeft(None: Option[ElGamalEnc])(_ ⊹ Some(_)))

def average[F[_]:Traverse](zero: PaillierEnc)(xs: F[Enc]): CryptoM[Enc] = for {
  sum <- sumA(zero)(xs)
  n <- encrypt(Additive) { xs.length }
  r <- sum / n
} yield r

def sorted(xs: List[Enc]): Crypto[List[OpeEnc]] =
  xs.traverse(toOpe).map(_.sorted)
#+END_SRC
** Free Monads
- Given any Functor, Free gives rise to a Monad over that Functor
  #+BEGIN_SRC scala
  sealed trait CryptoF[+K] //
  case class Plus[K](lhs:Enc,rhs:Enc,k:PaillierEnc => K) extends CryptoF[K]
  def plus(lhs:Enc,rhs:Enc):Crypto[Enc]
  // multiplication, equality, comparisons
  #+END_SRC
- We can use the power of the Monad to combine computations
  #+BEGIN_SRC scala
  def sum(xs: List[Enc]): Crypto[Enc] = xs match {
    case List() => enc(0)
    case (x::xs) => for (xs_ <- sum(xs)) yield (plus(x,xs_))
  }
  #+END_SRC
- Very lightweight DSL
*** Interpretation
- When using the DSL, we build up a data structure of our Functor
- Programs are first-class without semantics
- Interpretation = Step through and give semantics
#+BEGIN_SRC scala
def toAdditive(e: Enc): PaillierEnc = ???

def interpret[A](p: CryptoM[A]): A = p.resume match {
  case -\/(Plus(lhs@PaillierEnc(_),rhs@PaillierEnc(_),k)) => interpret(k(lhs+rhs))
  case -\/(Plus(lhs,rhs,k)) => interpret(k(toAdditive(lhs) + toAdditive(rhs)))
  // all the other cases...
}
#+END_SRC
*** Monadic interpretation
Two example programs to compute the sum, monadic vs applicative
#+BEGIN_SRC scala
def sumM(zero: PaillierEnc)(xs: List[Enc]): CryptoM[Enc] =
  xs.foldLeftM(zero)(add(_,_))

def sumA(zero: PaillierEnc)(xs: List[Enc]): Crypto[Enc] =
  xs.traverse(toPaillier).map(_.foldLeft(zero)(_+_))

val monadic     = sumM(E(0))(List(E(1),E(2),E(3)))
val applicative = sumA(E(0))(List(E(1),E(2),E(3)))
#+END_SRC

#+REVEAL: split
#+BEGIN_SRC scala
sumM(E(0))(List(E(1),E(2),E(3)))
#+END_SRC
#+BEGIN_SRC ditaa -Tpng :file monadic-interp-0.png
                     +------------+
                     |            |
                     |  Crypto    |
                     |   Service  |
                     |            |
                     +------------+



+------------+       +------------+       +------------+       +-----------+
|            |       |            |       |            |       |           |
|            |------>|            |------>|            |------>|           |
|   cBLK     |       |   cBLK     |       |   cBLK     |       |   cBLK    |
+------------+       +------------+       +------------+       +-----------+
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC scala
sumM(E(0))(List(E(1),E(2),E(3)))
#+END_SRC
#+BEGIN_SRC ditaa -Tpng :file monadic-interp-1.png
                     +------------+
                     |            |
                     |  Crypto    |
                     |   Service  |
                     |            |
                     +------------+



+------------+       +------------+       +------------+       +-----------+
|            |       |            |       |            |       |           |
|  Add(0,1)  |------>|            |------>|            |------>|           |
|   cBLU     |       |   cBLK     |       |   cBLK     |       |   cBLK    |
+------------+       +------------+       +------------+       +-----------+
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC scala
sumM(E(0))(List(E(1),E(2),E(3)))
#+END_SRC
#+BEGIN_SRC ditaa -Tpng :file monadic-interp-2.png
                     +------------+
                     |            |
      +------------->|  Crypto    |
      |              |   Service  |
      :              |    cBLU    |
      |              +------------+
      |
      |
      v
+------------+       +------------+       +------------+       +-----------+
|            |       |            |       |            |       |           |
|  Add(0,1)  |------>|            |------>|  cBLK      |------>| cBLK      |
|   cBLU     |       |   cBLK     |       |            |       |           |
+------------+       +------------+       +------------+       +-----------+
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC scala
sumM(E(0))(List(E(1),E(2),E(3)))
#+END_SRC
#+BEGIN_SRC ditaa -Tpng :file monadic-interp-3.png
                     +------------+
                     |            |
                     |  Crypto    |
                     |   Service  |
                     |            |
                     +------------+



+------------+       +------------+       +------------+       +-----------+
|            |   1   |            |       |            |       |           |
|  Add(0,1)  |------>|  Add(1,2)  |------>|   cBLK     |------>|  cBLK     |
|   cGRE     |       |   cBLU     |       |            |       |           |
+------------+       +------------+       +------------+       +-----------+
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC scala
sumM(E(0))(List(E(1),E(2),E(3)))
#+END_SRC
#+BEGIN_SRC ditaa -Tpng :file monadic-interp-4.png
                     +------------+
                     |            |
                     |  Crypto    |
                     |   Service  |
                     |    cBLU    |
                     +------------+
                           ^
                           |
                           v
+------------+       +------------+       +------------+       +-----------+
|            |   1   |            |       |            |       |           |
|  Add(0,1)  |------>|  Add(1,2)  |------>|      cBLK  |------>|     cBLK  |
|   cGRE     |       |   cBLU     |       |            |       |           |
+------------+       +------------+       +------------+       +-----------+
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC scala
sumM(E(0))(List(E(1),E(2),E(3)))
#+END_SRC
#+BEGIN_SRC ditaa -Tpng :file monadic-interp-5.png
                     +------------+
                     |            |
                     |  Crypto    |
                     |   Service  |
                     |            |
                     +------------+



+------------+       +------------+       +------------+       +-----------+
|            |   1   |            |   3   |            |       |           |
|  Add(0,1)  |------>|  Add(1,2)  |------>|  Add(3,3)  |------>|     cBLK  |
|   cGRE     |       |   cGRE     |       |   cBLU     |       |           |
+------------+       +------------+       +------------+       +-----------+
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC scala
sumM(E(0))(List(E(1),E(2),E(3)))
#+END_SRC
#+BEGIN_SRC ditaa -Tpng :file monadic-interp-6.png
                     +------------+
                     |            |
                     |  Crypto    |<------------+
                     |   Service  |             |
                     |    cBLU    |             |
                     +------------+             :
                                                |
                                                |
                                                v
+------------+       +------------+       +------------+       +-----------+
|            |   1   |            |   3   |            |       |           |
|  Add(0,1)  |------>|  Add(1,2)  |------>|  Add(3,3)  |------>|     cBLK  |
|   cGRE     |       |   cGRE     |       |   cBLU     |       |           |
+------------+       +------------+       +------------+       +-----------+
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC scala
sumM(E(0))(List(E(1),E(2),E(3)))
#+END_SRC
#+BEGIN_SRC ditaa -Tpng :file monadic-interp-7.png
                     +------------+
                     |            |
                     |  Crypto    |
                     |   Service  |
                     |            |
                     +------------+



+------------+       +------------+       +------------+       +-----------+
|            |   1   |            |   3   |            |   6   |           |
|  Add(0,1)  |------>|  Add(1,2)  |------>|  Add(3,3)  |------>|  Return 6 |
|   cGRE     |       |   cGRE     |       |   cGRE     |       |    cBLU   |
+------------+       +------------+       +------------+       +-----------+
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC scala
sumM(E(0))(List(E(1),E(2),E(3)))
#+END_SRC
#+BEGIN_SRC ditaa -Tpng :file monadic-interp-8.png
                     +------------+
                     |            |
                     |  Crypto    |
                     |   Service  |
                     |            |
                     +------------+



+------------+       +------------+       +------------+       +-----------+
|            |   1   |            |   3   |            |   6   |           |
|  Add(0,1)  |------>|  Add(1,2)  |------>|  Add(3,3)  |------>|  Return 6 |
|   cGRE     |       |   cGRE     |       |   cGRE     |       |    cGRE   |
+------------+       +------------+       +------------+       +-----------+
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC scala
sumA(E(0))(List(E(1),E(2),E(3)))
#+END_SRC
#+BEGIN_SRC ditaa -Tpng :file applicative-interp-0.png
                     +------------+
                     |            |
                     |  Crypto    |
                     |   Service  |
                     |            |
                     +------------+



+------------+       +------------+       +------------+       +-----------+
|            |       |            |       |            |       |           |
|            |------>|            |------>|            |------>|           |
|   cBLK     |       |   cBLK     |       |   cBLK     |       |   cBLK    |
+------------+       +------------+       +------------+       +-----------+
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC scala
sumA(E(0))(List(E(1),E(2),E(3)))
#+END_SRC
#+BEGIN_SRC ditaa -Tpng :file applicative-interp-1.png
                     +------------+
             1       |            |       3
      +------------->|  Crypto    |<------------+
      |              |   Service  |             |
      |              |    cBLU    |             |
      |              +------------+             |
      |                    ^                    |
      |                    | 2                  |
      v                    v                    v
+------------+       +------------+       +------------+       +-----------+
|            |       |            |       |            |       |           |
|toPaillier 1|------>|toPaillier 2|------>|toPaillier 3|------>|           |
|   cBLU     |       |   cBLU     |       |   cBLU     |       |   cBLK    |
+------------+       +------------+       +------------+       +-----------+
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC scala
sumA(E(0))(List(E(1),E(2),E(3)))
#+END_SRC
#+BEGIN_SRC ditaa -Tpng :file applicative-interp-2.png
                     +------------+
                     |            |
                     |  Crypto    |
                     |   Service  |
                     |            |
                     +------------+



+------------+       +------------+       +------------+       +-----------+
|            |       |            |       |            |       |           |
|toPaillier 1|------>|toPaillier 2|------>|toPaillier 3|------>|foldLeft + |
|   cGRE     |       |   cGRE     |       |   cGRE     |       |   cBLU    |
+------------+       +------------+       +------------+       +-----------+
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC scala
sumA(E(0))(List(E(1),E(2),E(3)))
#+END_SRC
#+BEGIN_SRC ditaa -Tpng :file applicative-interp-3.png
                     +------------+
                     |            |
                     |  Crypto    |
                     |   Service  |
                     |            |
                     +------------+



+------------+       +------------+       +------------+       +-----------+
|            |       |            |       |            |       |           |
|toPaillier 1|------>|toPaillier 2|------>|toPaillier 3|------>| Return 6  |
|   cGRE     |       |   cGRE     |       |   cGRE     |       |   cGRE    |
+------------+       +------------+       +------------+       +-----------+
#+END_SRC

** Free Monads - Pro and Cons
- The good:
  - programs are first-class
  - diffent interpreters:
    - local/remote, sequential/parallel, logging
- The bad:
  - programs are hard to analyze
  - power of Monads allows depending on previous effectful
    computations
  - no private key, no execution, no analysis
*** Free Applicative Functors
- Monads are too powerful
- We need something less powerful
- ∀m. Monad m ⇒ Applicative m
- Free Applicative Functors [[[http://dx.doi.org/10.4204/eptcs.153.2][CK14]]]
*** Analysis
- size of the program
- number of required conversions
- eliminate trivial conversions
  #+BEGIN_SRC scala
  case ToPaillier(PaillierEnc(_),_) => ???
  case ToPaillier(ElGamalEnc(_),_) => ???
  #+END_SRC
- perform all conversions before execution (private key)
- execute complete program in parallel
- extract list of schemes and numbers, do batch conversions
*** Applicative + Monad benefits
- many common operations are easily defined for applicative functors /
  monads
- already done in [[https://github.com/scalaz/scalaz][scalaz]]:
#+BEGIN_SRC scala
def traverse[A,B,F[_]:Applicative](f: A => F[B]): F[B]
def filterM[A,F[_]:Applicative](p: A => F[Boolean]): Crypto[List[A]]
def partitionM[A,F[_]:Applicative](p: A => F[Boolean]): Crypto[List[A]]

def foldLeftM[A,B,F[_]:Monad](z: B)(f: (B,A) => F[B]): F[B]
// takeWhileM, allM, anyM, spanM, breakM, groupWhenM
// unfoldTreeM
#+END_SRC
* Benchmarks
** Sequential, Parallel, Analyzing
[[file:delayed-bench-3.png]]
** Parallel, Analyzing
[[file:delayed-bench-2.png]]
